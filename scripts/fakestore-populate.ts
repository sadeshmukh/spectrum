import { writeFile } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import pLimit from "p-limit";
import { rewriteTitles } from "./lib/title-rewriter";
import { getOutputPath } from "./lib/output-utils";

interface FakeStoreProduct {
  id: number;
  title: string;
  price: number;
  description: string;
  category: string;
  image: string;
  rating: {
    rate: number;
    count: number;
  };
}

interface ScrapedItem {
  link: string;
  photoUrl: string | undefined;
  title: string | undefined;
  actualPrice: number | undefined;
}

const CONCURRENCY = 5;
const limit = pLimit(CONCURRENCY);

const CATEGORIES = [
  "electronics",
  "jewelery",
  "men's clothing",
  "women's clothing",
  "home",
  "sports",
  "automotive",
  "books",
  "toys",
  "health",
  "beauty",
  "garden",
  "tools",
  "baby",
  "outdoors",
];

async function delay(min: number, max: number) {
  const delayTime = min + Math.random() * (max - min);
  return new Promise((resolve) => setTimeout(resolve, delayTime));
}

async function fetchProductsFromCategory(
  category: string
): Promise<FakeStoreProduct[]> {
  try {
    await delay(1000, 3000);

    const response = await fetch(
      `https://fakestoreapi.com/products/category/${encodeURIComponent(
        category
      )}`
    );

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }

    const products: FakeStoreProduct[] = await response.json();
    return products.slice(0, 10);
  } catch (error) {
    console.error(`Failed to fetch products from category ${category}:`, error);
    return [];
  }
}

function convertToScrapedItem(product: FakeStoreProduct): ScrapedItem {
  return {
    link: `https://fakestoreapi.com/products/${product.id}`,
    photoUrl: product.image,
    title: product.title,
    actualPrice: product.price,
  };
}

async function fetchAllProducts(): Promise<ScrapedItem[]> {
  const allItems: ScrapedItem[] = [];
  const stats = { success: 0, failure: 0 };

  const selectedCategories = CATEGORIES.sort(() => Math.random() - 0.5).slice(
    0,
    8
  );

  console.log(
    `Fetching products from categories: ${selectedCategories.join(", ")}`
  );

  const categoryPromises = selectedCategories.map((category) =>
    limit(async () => {
      try {
        const products = await fetchProductsFromCategory(category);
        const items = products.map(convertToScrapedItem);

        allItems.push(...items);
        stats.success += items.length;

        console.log(`âœ… ${category}: ${items.length} products`);
        return items;
      } catch (error) {
        console.error(`âŒ ${category}: failed`);
        stats.failure++;
        return [];
      }
    })
  );

  await Promise.all(categoryPromises);

  console.log(
    `\nðŸ“Š Stats: ${stats.success} successful, ${stats.failure} failed`
  );
  return allItems;
}

async function writeScrapedData(items: ScrapedItem[]) {
  const validItems = items.filter((item) => {
    const isValid = item.title && item.actualPrice && item.actualPrice > 0;
    return isValid;
  });

  const outputPath = getOutputPath();

  const fileContent = `// This file is auto-generated by scripts/fakestore-populate.ts

export const scrapedItems = ${JSON.stringify(validItems, null, 2)} as const;
`;

  await writeFile(outputPath, fileContent, "utf-8");
  console.log(`Wrote ${validItems.length} valid items to ${outputPath}`);
}

async function main() {
  try {
    console.log("ðŸš€ Starting FakeStore API product collection...\n");

    const items = await fetchAllProducts();

    if (items.length === 0) {
      throw new Error("No items were collected");
    }

    await rewriteTitles(items);
    await writeScrapedData(items);

    console.log("\nâœ… Product collection completed successfully!");
  } catch (error) {
    console.error("=== Fatal Error ===");
    console.error(error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("=== Unhandled Error ===");
  console.error(error);
  process.exit(1);
});
