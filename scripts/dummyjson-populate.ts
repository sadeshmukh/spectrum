import { writeFile } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import pLimit from "p-limit";

interface DummyJsonProduct {
  id: number;
  title: string;
  description: string;
  price: number;
  discountPercentage: number;
  rating: number;
  stock: number;
  brand: string;
  category: string;
  thumbnail: string;
  images: string[];
}

interface ScrapedItem {
  link: string;
  photoUrl: string | undefined;
  title: string | undefined;
  actualPrice: number | undefined;
}

const CONCURRENCY = 3;
const limit = pLimit(CONCURRENCY);

const CATEGORIES = [
  "smartphones",
  "laptops",
  "fragrances",
  "skincare",
  "groceries",
  "home-decoration",
  "furniture",
  "tops",
  "womens-dresses",
  "womens-shoes",
  "mens-shirts",
  "mens-shoes",
  "mens-watches",
  "womens-watches",
  "womens-bags",
  "womens-jewellery",
  "sunglasses",
  "automotive",
  "motorcycle",
  "lighting",
];

async function delay(min: number, max: number) {
  const delayTime = min + Math.random() * (max - min);
  return new Promise((resolve) => setTimeout(resolve, delayTime));
}

async function fetchProductsFromCategory(
  category: string,
  limit = 10
): Promise<DummyJsonProduct[]> {
  try {
    await delay(2000, 5000);

    const response = await fetch(
      `https://dummyjson.com/products/category/${encodeURIComponent(
        category
      )}?limit=${limit}`
    );

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }

    const data = await response.json();
    return data.products || [];
  } catch (error) {
    console.error(`Failed to fetch products from category ${category}:`, error);
    return [];
  }
}

function convertToScrapedItem(product: DummyJsonProduct): ScrapedItem {
  const discountedPrice =
    product.price * (1 - product.discountPercentage / 100);

  return {
    link: `https://dummyjson.com/products/${product.id}`,
    photoUrl: product.thumbnail,
    title: product.title,
    actualPrice: Math.round(discountedPrice * 100) / 100,
  };
}

async function fetchAllProducts(): Promise<ScrapedItem[]> {
  const allItems: ScrapedItem[] = [];
  const stats = { success: 0, failure: 0 };

  const selectedCategories = CATEGORIES.sort(() => Math.random() - 0.5).slice(
    0,
    10
  );

  console.log(
    `Fetching products from categories: ${selectedCategories.join(", ")}`
  );

  const categoryPromises = selectedCategories.map((category) =>
    limit(async () => {
      try {
        const products = await fetchProductsFromCategory(category, 8);
        const items = products.map(convertToScrapedItem);

        allItems.push(...items);
        stats.success += items.length;

        console.log(`âœ… ${category}: ${items.length} products`);
        return items;
      } catch (error) {
        console.error(`âŒ ${category}: failed`);
        stats.failure++;
        return [];
      }
    })
  );

  await Promise.all(categoryPromises);

  console.log(
    `\nðŸ“Š Stats: ${stats.success} successful, ${stats.failure} failed`
  );
  return allItems;
}

async function writeScrapedData(items: ScrapedItem[]) {
  const validItems = items.filter((item) => {
    const isValid = item.title && item.actualPrice && item.actualPrice > 0;
    return isValid;
  });

  const outputPath = join(
    dirname(fileURLToPath(import.meta.url)),
    "..",
    "db",
    "scraped-items.ts"
  );

  const fileContent = `// This file is auto-generated by scripts/dummyjson-populate.ts

export const scrapedItems = ${JSON.stringify(validItems, null, 2)} as const;
`;

  await writeFile(outputPath, fileContent, "utf-8");
  console.log(`Wrote ${validItems.length} valid items to ${outputPath}`);
}

async function main() {
  try {
    console.log("ðŸš€ Starting DummyJSON API product collection...\n");

    const items = await fetchAllProducts();

    if (items.length === 0) {
      throw new Error("No items were collected");
    }

    await writeScrapedData(items);

    console.log("\nâœ… Product collection completed successfully!");
  } catch (error) {
    console.error("=== Fatal Error ===");
    console.error(error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("=== Unhandled Error ===");
  console.error(error);
  process.exit(1);
});
