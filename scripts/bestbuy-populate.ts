import { scrapeBestBuyPrice } from "../src/lib/bestbuy-scraper";
import { uploadToCloudflareR2 } from "../src/lib/cloudflare-r2";
import { writeFile } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import ProgressBar from "progress";
import { rewriteTitles } from "./lib/title-rewriter";

const SEARCH_TERMS = [
  "laptop",
  "smartphone",
  "headphones",
  "tv",
  "gaming console",
  "camera",
  "tablet",
  "monitor",
  "keyboard",
  "mouse",
  "speaker",
  // "microphone",
  // "router",
  // "printer",
  // "scanner",
];

// const TOTAL_SEARCH_URLS = 3;
// ^ for testing, to retrieve non stale items
const TOTAL_SEARCH_URLS = SEARCH_TERMS.length;
const MAX_PRODUCT_URLS = 5;

const USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36",
];

function getRandomUserAgent() {
  return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

async function delay(min: number, max: number) {
  const delayTime = min + Math.random() * (max - min);
  return new Promise((resolve) => setTimeout(resolve, delayTime));
}

async function generateSearchUrls(count = 20) {
  return Array.from({ length: count }, () => {
    const term = SEARCH_TERMS[Math.floor(Math.random() * SEARCH_TERMS.length)];
    return `https://www.bestbuy.com/site/searchpage.jsp?st=${encodeURIComponent(
      term
    )}`;
  });
}

async function extractProductUrls(searchUrl: string): Promise<string[]> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);

    const response = await fetch(searchUrl, {
      signal: controller.signal,
      headers: {
        "User-Agent": getRandomUserAgent(),
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.9",
        "Accept-Encoding": "gzip, deflate, br",
        "Cache-Control": "no-cache",
        "Sec-Ch-Ua":
          '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
        "Sec-Ch-Ua-Mobile": "?0",
        "Sec-Ch-Ua-Platform": '"Windows"',
        "Sec-Fetch-Dest": "document",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-Site": "none",
        "Sec-Fetch-User": "?1",
        "Upgrade-Insecure-Requests": "1",
        Referer: "https://www.bestbuy.com/",
      },
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }

    const html = await response.text();

    const urlSet = new Set<string>();

    const productUrlMatches = html.matchAll(
      /href="(https:\/\/www\.bestbuy\.com\/site\/[^"]*\/[A-Z0-9]+\.p\?skuId=[A-Z0-9]+)"/g
    );

    for (const [, url] of productUrlMatches) {
      urlSet.add(url);
    }

    const relativeUrlMatches = html.matchAll(
      /href="(\/site\/[^"]*\/[A-Z0-9]+\.p\?skuId=[A-Z0-9]+)"/g
    );

    for (const [, path] of relativeUrlMatches) {
      urlSet.add(`https://www.bestbuy.com${path}`);
    }

    const urls = [...urlSet].slice(0, 5);
    return urls;
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      console.error(`Timeout extracting products from ${searchUrl}`);
    } else {
      console.error(`Failed to extract products from ${searchUrl}:`, error);
    }
    return [];
  }
}

interface ScrapedItem {
  link: string;
  photoUrl: string | undefined;
  title: string | undefined;
  actualPrice: number | undefined;
}

async function writeScrapedData(items: ScrapedItem[]) {
  const validItems = items.filter((item) => {
    const isValid = item.title && item.actualPrice && item.actualPrice > 0;
    return isValid;
  });

  const outputPath = join(
    dirname(fileURLToPath(import.meta.url)),
    "..",
    "db",
    "scraped-items.ts"
  );

  const fileContent = `// This file is auto-generated by scripts/bestbuy-populate.ts

export const scrapedItems = ${JSON.stringify(validItems, null, 2)} as const;
`;

  await writeFile(outputPath, fileContent, "utf-8");
  console.log(`\nWrote ${validItems.length} valid items to ${outputPath}`);
  console.log(
    `Items with images: ${validItems.filter((item) => item.photoUrl).length}`
  );
  console.log(
    `Items without images: ${
      validItems.filter((item) => !item.photoUrl).length
    }`
  );
}

async function main() {
  try {
    console.log("ðŸš€ Starting BestBuy product collection...\n");

    const items: ScrapedItem[] = [];
    const stats = { success: 0, failure: 0 };

    const searchUrls = await generateSearchUrls(
      Math.min(TOTAL_SEARCH_URLS, SEARCH_TERMS.length)
    );

    console.log(`Generated ${searchUrls.length} search URLs`);

    const searchProgress = new ProgressBar(
      "Processing search :current/:total [:bar] :percent :etas",
      {
        complete: "â–ˆ",
        incomplete: "â–‘",
        width: 40,
        total: searchUrls.length,
      }
    );

    for (const searchUrl of searchUrls) {
      try {
        console.log(`\nExtracting product URLs from: ${searchUrl}`);
        const productUrls = (await extractProductUrls(searchUrl)).slice(
          0,
          MAX_PRODUCT_URLS
        );
        console.log(`Found ${productUrls.length} product URLs`);

        if (productUrls.length === 0) {
          searchProgress.tick();
          continue;
        }

        const productProgress = new ProgressBar(
          "  Scraping products :current/:total [:bar] :percent :etas",
          {
            complete: "â–ˆ",
            incomplete: "â–‘",
            width: 30,
            total: productUrls.length,
          }
        );

        const results: (ScrapedItem | null)[] = [];

        for (const url of productUrls) {
          try {
            await delay(500, 1000);
            const result = await scrapeBestBuyPrice(url);

            if (result.success && result.data) {
              const { title, price, image: photoUrl } = result.data;

              let cloudflareImageUrl: string | undefined;
              if (photoUrl) {
                try {
                  cloudflareImageUrl = await uploadToCloudflareR2(photoUrl);
                } catch (uploadError) {
                  console.error(`Failed to upload image: ${uploadError}`);
                  cloudflareImageUrl = undefined;
                }
              }

              const item: ScrapedItem = {
                link: url,
                photoUrl: cloudflareImageUrl,
                title: title || undefined,
                actualPrice: price || undefined,
              };
              results.push(item);
            } else {
              results.push(null);
            }
            productProgress.tick();
          } catch (error) {
            console.error(`\nError scraping ${url}:`, error);
            results.push(null);
            productProgress.tick();
          }
        }

        const successfulItems = results.filter(
          (item): item is ScrapedItem => item !== null
        );

        items.push(...successfulItems);
        stats.success += successfulItems.length;
        stats.failure += results.length - successfulItems.length;

        searchProgress.tick();
        await delay(1000, 2000);
      } catch (searchError) {
        console.error(`\nError processing search ${searchUrl}:`, searchError);
        stats.failure++;
        searchProgress.tick();
      }
    }

    if (items.length === 0) {
      throw new Error("No items were collected");
    }

    await rewriteTitles(items);
    await writeScrapedData(items);

    console.log("\nProduct collection completed successfully!");
    console.log(
      `Summary: ${stats.success} successful, ${stats.failure} failed`
    );
  } catch (error) {
    console.error("=== Fatal Error ===");
    console.error(error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("=== Unhandled Error ===");
  console.error(error);
  process.exit(1);
});
